# Node.js 숙련 주차 개인 과제

# 환경변수

- .env.sample 파일 체크

# API 명세서 URL

- https://docs.google.com/spreadsheets/d/1cHSXYOKN9E4OyasjgxSsuxRb7DV8nx5oIntjT5TLZZM/edit#gid=0

# ERD URL

- https://www.erdcloud.com/d/xgTGMYdQDimG7AoFW

# 더 고민해 보기

1. **암호화 방식**

- 비밀번호를 DB에 저장할 때 Hash를 이용했는데, Hash는 `단방향 암호화`와 `양방향 암호화` 중 어떤 암호화 방식에 해당할까요?
  : Hash는 단방향 암호화 방식에 해당합니다. 원본 데이터를 암호화한 후에는 복호화를 통해 원본 데이터로 돌아갈 수 없습니다.
- 비밀번호를 그냥 저장하지 않고 Hash 한 값을 저장 했을 때의 좋은 점은 무엇인가요?
  : 비밀번호를 그냥 저장하지 않고 Hash 한 값으로 저장하면,
  실제 비밀번호가 유출되더라도 사용자의 정보를 보호할 수 있습니다.
  또한, 각 사용자의 비밀번호를 비교할 수 없어 개인정보 보호에 도움이 됩니다.

2. **인증 방식**

- JWT(Json Web Token)을 이용해 인증 기능을 했는데, 만약 Access Token이 노출되었을 경우 발생할 수 있는 문제점은 무엇일까요?
  : Access Token이 노출되면 누군가 그 토큰을 사용해 사용자의 권한으로 행동할 수 있습니다. 이는 개인정보 유출, 무단 액세스 등의 문제를 일으킬 수 있습니다.
- 해당 문제점을 보완하기 위한 방법으로는 어떤 것이 있을까요?
  : 'Refresh Token'을 사용하거나, Access Token의 유효기간을 짧게 설정하고 자주 갱신하는 방법이 있습니다.

3. **인증과 인가**

- 인증과 인가가 무엇인지 각각 설명해 주세요.
  : 인증(Authentication)은 사용자가 누구인지 확인하는 과정입니다. 로그인 과정에서 이루어집니다.
  인가(Authorization)는 해당 사용자가 어떤 권한을 가지고 있는지 확인하는 과정입니다. 특정 페이지 접근이나 API 요청 시에 이루어집니다.
- 과제에서 구현한 Middleware는 인증에 해당하나요? 인가에 해당하나요? 그 이유도 알려주세요.
  : 둘 모두 해당됩니다. 로그인 여부를 확인하는 부분은 인증, 특정 권한을 가진 사용자만 요청 가능한 API를 제한하는 부분은 인가에 해당합니다.

4. **Http Status Code**

- 과제를 진행하면서 `사용한 Http Status Code`를 모두 나열하고, 각각이 `의미하는 것`과 `어떤 상황에 사용`했는지 작성해 주세요.
  : OK(200) - 요청이 성공적으로 처리되었음을 나타냅니다. GET 요청 성공 시 사용합니다.
  CREATED(201) - 새로운 리소스가 생성되었음을 나타냅니다. POST 요청 성공 시 사용합니다.
  BAD_REQUEST(400) - 클라이언트의 요청이 유효하지 않음을 나타냅니다. 잘못된 요청 시 사용합니다.
  UNAUTHORIZED(401) - 사용자 인증이 필요함을 나타냅니다. 로그인이 필요한 요청 시 사용합니다.
  FORBIDDEN(403) - 서버가 요청을 이해하였지만, 수행을 거부함을 나타냅니다. 권한이 없는 요청 시 사용합니다.
  NOT_FOUND(404) - 요청한 리소스를 찾을 수 없음을 나타냅니다. 존재하지 않는 페이지 요청 시 사용합니다.
  CONFLICT(409) - 요청이 서버의 현재 상태와 충돌함을 나타냅니다. 중복된 데이터 요청 시 사용합니다.
  INTERNAL_SERVER_ERROR(500) - 서버에서 처리 방법을 알 수 없는 상황이 발생하였음을 나타냅니다. 서버 내부 에러 발생 시 사용합니다.

5. **리팩토링**

- MongoDB, Mongoose를 이용해 구현되었던 코드를 MySQL, Sequelize로 변경하면서, 많은 코드 변경이 있었나요? 주로 어떤 코드에서 변경이 있었나요?
  : 기존 코드를 재활용해 변경하지 않고 아예 코드를 새로 짜서 어느 정도의 코드 변경이 있었는지 정확히 가늠할 수는 없지만, DB 연결 코드와 모델 정의 코드, 쿼리 수행 코드 등의 변경이 가장 많았던 거 같습니다.
- 만약 이렇게 DB를 변경하는 경우가 또 발생했을 때, 코드 변경을 보다 쉽게 하려면 어떻게 코드를 작성하면 좋을 지 생각나는 방식이 있나요? 있다면 작성해 주세요.
  : DB 연결과 쿼리 수행을 담당하는 부분을 분리하고, 인터페이스를 통해 DB를 사용하는 방식이 좋을 것 같습니다.

6. **서버 장애 복구**

- 현재는 PM2를 이용해 Express 서버의 구동이 종료 되었을 때에 Express 서버를 재실행 시켜 장애를 복구하고 있습니다. 만약 단순히 Express 서버가 종료 된 것이 아니라, AWS EC2 인스턴스(VM, 서버 컴퓨터)가 재시작 된다면, Express 서버는 재실행되지 않을 겁니다. AWS EC2 인스턴스가 재시작 된 후에도 자동으로 Express 서버를 실행할 수 있게 하려면 어떤 조치를 취해야 할까요?
  (Hint: PM2에서 제공하는 기능 중 하나입니다.)
  : PM2의 startup 옵션을 사용하여, 시스템 부팅 시 자동으로 애플리케이션을 시작할 수 있습니다.

7. **개발 환경**

- nodemon은 어떤 역할을 하는 패키지이며, 사용했을 때 어떤 점이 달라졌나요?
  : nodemon은 소스 코드가 변경될 때 자동으로 서버를 재시작하는 역할을 합니다. 이를 사용하면 개발 과정에서 코드 변경 이후 수동으로 서버를 재시작할 필요가 없어집니다.
- npm을 이용해서 패키지를 설치하는 방법은 크게 일반, 글로벌(`--global, -g`), 개발용(`--save-dev, -D`)으로 3가지가 있습니다. 각각의 차이점을 설명하고, nodemon은 어떤 옵션으로 설치해야 될까요?
  : 일반 설치는 프로젝트 내에서 사용되는 패키지를 설치합니다.
  글로벌 설치는 시스템 전체에서 사용되는 패키지를 설치합니다.
  개발용 설치는 개발 과정에서만 필요한 패키지를 설치합니다.
  nodemon은 개발 과정에서만 필요하므로 개발용 옵션으로 설치합니다.
